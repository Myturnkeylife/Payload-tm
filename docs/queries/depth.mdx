---
title: Depth
label: Depth
order: 20
desc: Payload depth determines how many levels down related documents should be automatically populated when retrieved.
keywords: query, documents, pagination, documentation, Content Management System, cms, headless, javascript, node, react, nextjs
---

Documents in Payload can have relationships to other Documents. When you query a Document, you can specify how many levels deep you want to populate related Documents.

You can specify population `depth` via query parameter in the REST API and by an option in the local API. _Depth has no effect in the GraphQL API, because there, depth is based on the shape of your queries._
It is also possible to limit the depth for specific `relation` and `upload` fields using the `maxDepth` property in your configuration.
**For example, let's look at the following Collections:** `departments`, `users`, `posts`

```
// type: 'relationship' fields are equal to 1 depth level

{
	slug: 'posts',
	fields: [
		{
			name: 'title',
			type: 'text',
		},
		{
			name: 'author',
			label: 'Post Author',
			type: 'relationship',
			relationTo: 'users',
		}
	]
}

{
	slug: 'users',
	fields: [
		{
			name: 'email',
			type: 'email',
		},
		{
			name: 'department'
			type: 'relationship',
			relationTo: 'departments'
		}
	]
}

{
	slug: 'departments',
	fields: [
		{
			name: 'name'
			type: 'text',
		}
	]
}
```

If you were to query the Posts endpoint at, say, `http://localhost:3000/api/posts?depth=1`, you will retrieve Posts with populations one level deep. This depth parameter can be thought of as N, where N is the number of levels you want to populate. To populate one level further, you would simply specify N+1 as the depth. A returned result may look like the following:

```
// ?depth=1

{
  id: '5ae8f9bde69e394e717c8832',
  title: 'This post sucks',
  author: {
    id: '5f7dd05cd50d4005f8bcab17',
    email: 'spiderman@superheroes.gov',
    department: '5e3ca05cd50d4005f8bdab15'
  }
}
```

Notice how the `user.author` is fully populated, but `user.author.department` is left as a document ID? That's because the User collection counted as the first level of `depth` and got populatedâ€”but then prevented any further populations from taking place.

To populate `user.author.department` in it's entirety you could specify `?depth=2` or _higher_.

```
// ?depth=2

{
  id: '5ae8f9bde69e394e717c8832',
  title: 'This post sucks',
  author: {
    id: '5f7dd05cd50d4005f8bcab17',
    email: 'spiderman@superheroes.gov',
    department: {
      id: '5e3ca05cd50d4005f8bdab15',
      name: 'Marvel'
    }
  }
}
```

### Field-level max depth

Fields like relationships or uploads can have a `maxDepth` property that limits the depth of the population for that field. Here are some examples:

Depth: 10
Current depth when field is accessed: 1
`maxDepth`: undefined

In this case, the field would be populated to 9 levels of population.

Depth: 10
Current depth when field is accessed: 0
`maxDepth`: 2

In this case, the field would be populated to 2 levels of population, despite there being a remaining depth of 8.

Depth: 10
Current depth when field is accessed: 2
`maxDepth`: 1

In this case, the field would not be populated, as the current depth (2) has exceeded the `maxDepth` for this field (1).

<Banner type="warning">
  <strong>Note:</strong>
  <br />
  When access control on collections prevents relationship fields from populating, the API response
  will contain the relationship id instead of the full document.
</Banner>
